export interface Ref<T = any> {
  current: T | null;
}
export interface PortalOptions {
  key?: string;
  onMount?: (container: Element) => void;
  onUnmount?: (container: Element) => void;
}
interface EffectOptions {
  deps?: (string | StateGetter<any>)[];
  immediate?: boolean;
  detectDeps?: boolean;
  beforeHydration?: boolean;
}
export interface Portal {
  id: string;
  content: HTMLElement | DocumentFragment | string;
  container: Element;
  component: string;
  cleanup?: () => void;
  renderedContent?: Element;
}
type LocalStoreState = Record<string, any>;
type SearchParamsListener = (params: URLSearchParams) => void;
type StateValue<T> = T extends undefined ? T | undefined : T;
type StateSetter<T> = (value: T | ((prev: T) => T)) => void;
type StateGetter<T> = (() => T) & {
  value: T;
  __pphp_key?: string;
  __pphp_fullKey?: string;
  __pphp_component?: string;
};
declare enum HydrationPhase {
  NOT_STARTED = "not_started",
  SCRIPTS_EXECUTING = "scripts_executing",
  LOOPS_PROCESSING = "loops_processing",
  EFFECTS_RUNNING = "effects_running",
  PORTALS_RENDERING = "portals_rendering",
  COMPLETE = "complete",
}
interface LifecycleHooks {
  beforeScripts?: () => void;
  afterScripts?: () => void;
  beforeLoops?: () => void;
  afterLoops?: () => void;
  beforeEffects?: () => void;
  afterEffects?: () => void;
  beforePortals?: () => void;
  afterPortals?: () => void;
}

export declare class PPHP {
  hydrationStarted: boolean;
  hydrationDone: boolean;
  protected static instance: PPHP | null;
  protected initialized: boolean;
  private stateManager;
  private expressionEvaluator;
  private componentManager;
  private domBindingManager;
  private hydrationCallbacks;
  private portalManager;
  private hydrationResolve;
  private hydrationPromise;
  private portalHydrationPromises;
  private portalHydrationResolvers;
  private lifecycleManager;
  private pendingEffects;
  constructor();
  initialize(): Promise<void>;
  private processAllLoops;
  private runPendingEffects;
  private triggerLoopUpdatesFromEffects;
  onPhase(phase: HydrationPhase, callback: () => void): void;
  waitForPhase(phase: HydrationPhase): Promise<void>;
  registerLifecycleHooks(hooks: LifecycleHooks): void;
  private disconnectObservers;
  private reconnectObservers;
  private scheduleCommentCleanup;
  createPortal(
    content: HTMLElement | DocumentFragment | string,
    container: Element | string,
    options?: PortalOptions
  ): string;
  removePortal(portalId: string): boolean;
  hasPortal(portalId: string): boolean;
  getPortal(portalId: string): Portal | undefined;
  markPortalHydrated(portalId: string): void;
  updatePortal(
    portalId: string,
    content: HTMLElement | DocumentFragment | string,
    options?: PortalOptions
  ): boolean;
  protected cleanup(): void;
  ref<T = any>(initialValue?: T | null): Ref<T>;
  hydrated(): Promise<void>;
  onHydrated(cb: () => void): void;
  private markHydrationStart;
  get isHydrated(): boolean;
  get isHydrating(): boolean;
  private markHydrated;
  state<T>(
    keyOrInitialValue: string | T,
    initialValue?: T
  ): [StateGetter<StateValue<T>>, StateSetter<StateValue<T>>];
  private looksLikeVariableName;
  effect(
    callback: () => void | (() => void),
    depsOrOptions?: (string | StateGetter<any>)[] | EffectOptions
  ): () => void;
  private extractDependencyNames;
  private resolveDependencies;
  private createComponentScopedGlobals;
  protected deleteAllComponentObjects(): void;
  static resetInstance(): void;
  destroy(): void;
}
export declare class PPHPUtilities extends PPHP {
  protected static instance: PPHPUtilities | null;
  private cryptoKey;
  private activeAbortController;
  private navigationEnabled;
  private boundHandleLinkClick;
  private boundHandlePopState;
  private isNavigating;
  private loadedDynamicScripts;
  private readonly RESET_SCROLL_ATTR;
  private constructor();
  private disableTransitions;
  private enableTransitions;
  private restoreBodyAccessibility;
  static resetInstance(): void;
  static getInstance(): PPHPUtilities;
  enableSPANavigation(): void;
  disableSPANavigation(): void;
  private handleLinkClick;
  private handlePopState;
  navigateTo(url: string, pushState?: boolean): Promise<void>;
  private getResetScrollConfig;
  private handleScrollRestoration;
  private saveScrollPositions;
  private getElementKey;
  private updatePageContentWithViewTransition;
  private dispatchNavigationEvent;
  private showLoadingTransition;
  private fetchPageContent;
  private updateBrowserHistory;
  private updatePageContent;
  private handleNavigationCompletion;
  private handleNavigationError;
  private findLoadingElement;
  private updateContentWithTransition;
  private parseTransition;
  private fadeOut;
  private fadeIn;
  private parseTime;
  private reconcileHead;
  redirect(url: string): Promise<void>;
  private initCryptoKey;
  private encryptCallbackName;
  private createFetchOptions;
  fetchFunction<T = any>(
    functionName: string,
    data?: Record<string, any>,
    abortPrevious?: boolean
  ): Promise<T | string>;
}
export declare class PPHPLocalStore {
  state: LocalStoreState;
  private static instance;
  private listeners;
  private pp;
  private STORAGE_KEY;
  private lastSyncedState;
  private constructor();
  static getInstance(initialState?: LocalStoreState): PPHPLocalStore;
  private getCookie;
  setState(update: Partial<LocalStoreState>, syncWithBackend?: boolean): void;
  private saveState;
  private loadState;
  resetState(id?: string, syncWithBackend?: boolean): void;
}
export declare class SearchParamsManager {
  private static instance;
  private listeners;
  private constructor();
  static getInstance(): SearchParamsManager;
  get params(): URLSearchParams;
  get(key: string): string | null;
  set(key: string, value: string): void;
  delete(key: string): void;
  replace(params: Record<string, string | null>): void;
  private updateURL;
  listen(callback: SearchParamsListener): void;
  private notifyListeners;
  enablePopStateListener(): void;
}
export {};
