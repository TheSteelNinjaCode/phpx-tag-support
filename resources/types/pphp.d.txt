declare global {
    interface EventTarget {
        removeAllEventListeners(type?: string): void;
    }
}
type LocalStoreState = Record<string, any>;
type SearchParamsListener = (params: URLSearchParams) => void;
declare class PPHP {
    props: Record<string, any>;
    private _isNavigating;
    private _responseData;
    private _elementState;
    private _activeAbortController;
    private _reservedWords;
    private _declaredStateRoots;
    private _arrayMethodCache;
    private _updateScheduled;
    private _pendingBindings;
    private _effects;
    private _pendingEffects;
    private _processedPhpScripts;
    private _bindings;
    private _templateStore;
    private _inlineDepth;
    private _proxyCache;
    private _rawProps;
    private _refs;
    private _wheelHandlersStashed;
    private _evaluatorCache;
    private _depsCache;
    private _dirtyDeps;
    private _handlerCache;
    private _handlerProxyCache;
    private _sharedStateMap;
    private _processedLoops;
    private _hydrated;
    private _currentProcessingHierarchy;
    private _stateHierarchy;
    private _inlineModuleFns;
    private _currentExecutionScope;
    private _transitionStyleInjected;
    private _currentEffectContext;
    private _currentEventTarget;
    private _eventContextStack;
    private _currentProcessingElement;
    private readonly _eventHandlers;
    private readonly _redirectRegex;
    private readonly _assignmentRe;
    private readonly _mustacheRe;
    private readonly _mutators;
    private readonly _boolAttrs;
    private static _instance;
    private static _effectCleanups;
    private static _debounceTimers;
    private static _shared;
    private static _cryptoKey;
    private static readonly _cancelableEvents;
    private static readonly _mustacheTest;
    private static readonly _mustachePattern;
    private static readonly _passiveEvents;
    private constructor();
    static get instance(): PPHP;
    debugProps(): void;
    private setupGlobalEventTracking;
    private scheduleInitialHydration;
    hydratePortal(root?: ParentNode): Promise<void>;
    private getPreservedPortalHierarchy;
    private initCryptoKey;
    private encryptCallbackName;
    private decryptCallbackName;
    private qsa;
    private bootstrapDeclarativeState;
    private detectComponentHierarchy;
    private detectElementHierarchy;
    private generateScopedKey;
    ref(key: string, index?: number): HTMLElement | HTMLElement[];
    effect(fn: () => void | (() => void), deps?: (string | (() => any))[]): () => void;
    private resolveDependencyPath;
    private getResolvedValue;
    private hasValueChanged;
    private resetProps;
    private initReactiveOn;
    private markPortalChildrenWithHierarchy;
    private removeAllEventListenersOnNavigation;
    private initLoopBindings;
    private registerLoop;
    private processIfChainsInFragment;
    private extractComprehensiveLoopDependencies;
    private extractItemPropertiesFromTemplate;
    private parseForExpression;
    private setupLoopMarker;
    private initializeLoopState;
    private createItemNodes;
    private processTextNodesInFragment;
    private createTextNodeUpdaterWithItemKey;
    private findItemByKey;
    private processElementBindingsInFragment;
    private processElementBindings;
    private createElementAttributeTemplateBindingWithItemKey;
    private createAttributeTemplateUpdaterWithItemKey;
    private renderAttributeTemplate;
    private createElementBindingWithItemKey;
    private createElementBindingUpdaterWithItemKey;
    private getItemKey;
    private renderTextNode;
    private renderMustacheText;
    private updateElementBinding;
    private renderElementBinding;
    private applyAttributeBinding;
    private processEventHandlersInFragment;
    private _idxOf;
    private updateItemNodes;
    private updateConditionalNodes;
    private updateNodesContent;
    private updateElementContent;
    private updateElementTemplateAttributes;
    private updateElementBindingsContent;
    private createLoopUpdater;
    private captureFocusState;
    private restoreFocusState;
    private calculateLoopDiff;
    private applyLoopChanges;
    private applyLoopUpdates;
    private applyLoopInsertions;
    private performLoopUpdate;
    private applyLoopDeletions;
    private initRefs;
    private scheduleBindingUpdate;
    private makeReactive;
    private shouldUnwrapValue;
    private getBindingType;
    private makeAttrTemplateUpdater;
    private formatValue;
    private registerBinding;
    private makeSafeEvaluator;
    private makeScopedEvaluator;
    private _createScopedPropsContext;
    private extractScopedDependencies;
    private processIfChains;
    private manageAttributeBindings;
    private callInlineModule;
    private getScopedFunction;
    private processInlineModuleScripts;
    private transformEffectDependencies;
    private smartSplitDependencies;
    private stateDeclarations;
    private injectScopedVariables;
    private extractStateVariables;
    private extractDeclaredVariables;
    private findScopedKeyForVariable;
    private extractVariableReferences;
    private shouldSkipVariableInjection;
    private isInDestructuringPattern;
    private isActualFunctionParameter;
    private isInDestructuringDeclaration;
    private hasInScopedContext;
    private _registerScopedFunction;
    private extractSetters;
    private markShared;
    private transformStateDeclarations;
    private stripComments;
    private flushBindings;
    private static readonly ARRAY_INTRINSICS;
    private static headMatch;
    private dependencyMatches;
    private matchEffectDependency;
    private matchLoopDependency;
    private isArrayPath;
    private isArrayItemPath;
    private matchBindingDependency;
    private matchesWildcardPattern;
    private matchesArrayIndexPattern;
    private scheduleFlush;
    private getNested;
    private setNested;
    private hasNested;
    share<T>(key: string, initial?: T): [(() => T) & {
        value: T;
    }, (v: T | ((p: T) => T)) => void];
    getShared<T = any>(key: string): T & ((...args: any[]) => T) & {
        set: (value: T | ((prev: T) => T)) => void;
    };
    clearShare: (key?: string) => void;
    state<T>(key?: string, initial?: T): [(() => T) & {
        value: T;
    }, (value: T | ((prev: T) => T)) => void];
    private markNestedPropertiesDirty;
    private static readonly _isBuiltIn;
    private extractDependencies;
    private isInlineModuleFunction;
    private looksLikeFunctionName;
    private isPlainText;
    private initializeAllReferencedProps;
    dispatchEvent(target: string, value: any | ((prev: any) => any), opts?: {
        scope?: "current" | "parent" | "root" | string | string[];
        from?: Element;
    }): Promise<string | false>;
    private determineCurrentComponentHierarchy;
    private trackEventContext;
    private getEventSourceHierarchy;
    private getCurrentScriptHierarchy;
    private getActiveElementHierarchy;
    private buildComponentHierarchy;
    private resolveStatePath;
    getCurrentComponent(selector?: string): string | null;
    private findComponentFromElement;
    private getFallbackComponent;
    getCurrentComponentHierarchy(): string[];
    private updateDocumentContent;
    private ensurePageTransitionStyles;
    private fadeOutBody;
    private fadeInBody;
    private reconcileHead;
    private scrubTemplateValueAttributes;
    private restoreScrollPositions;
    private PRESERVE_HANDLERS;
    private populateDocumentBody;
    private saveScrollPositions;
    private getElementKey;
    private attachWireFunctionEvents;
    private decodeEntities;
    private unwrapArrowBody;
    private buildHandlerFromRawBody;
    private replaceThisReferences;
    private normalizeToArrow;
    private renameEventParam;
    private escapeRegex;
    private handleDebounce;
    debounce<T extends (...args: any[]) => void>(func: T, wait?: number, immediate?: boolean): (...args: Parameters<T>) => void;
    private invokeHandler;
    private parseHandler;
    private isArrowFunction;
    private parseArrowFunction;
    private findArrowIndex;
    private executeArrowHandler;
    private executeComplexHandler;
    private parseStatements;
    private executeInlineModule;
    private executeSingleStatement;
    private executeCallHandler;
    private resolveFunctionName;
    private executeSimpleHandler;
    private executeHandler;
    private executeGlobalFunction;
    private executeDynamic;
    private static AsyncFunction;
    private getOrCreateEvaluator;
    private getOrCreateProxy;
    private createHandlerProxy;
    private isAsyncFunction;
    private containsAwait;
    private handleInvokeError;
    private handleParsedCallback;
    private shouldCallServer;
    private resolveLocalFunction;
    private handleUndefinedFunction;
    private handleAfterRequest;
    private sanitizePassiveHandlers;
    private handlePassiveWheelStashes;
    private handleResponseRedirectOrUpdate;
    private getUpdatedHTMLContent;
    private updateBodyContent;
    private restoreElementState;
    private appendCallbackResponse;
    private saveElementState;
    private updateElementAttributes;
    private decodeHTML;
    private appendAfterbegin;
    private restoreSuspenseElement;
    private extractJson;
    private getRedirectUrl;
    private fetchFileWithData;
    private handleSuspenseElement;
    private toggleFormElements;
    private saveElementOriginalState;
    private getUrlParams;
    private createFetchOptions;
    private parseCallback;
    private clean;
    private evaluateJavaScriptObject;
    private handleInputElement;
    private handleInputAppendParams;
    private handleHiddenAttribute;
    private handleVisibilityElementAttribute;
    private handleElementVisibility;
    private handleElementDisplay;
    private handleElementChange;
    private handleAnchorTag;
    private handlePopState;
    private handleNavigation;
    private findLoadingElement;
    private updateContentWithTransition;
    private parseTransition;
    private fadeOut;
    private fadeIn;
    redirect(url: string): Promise<void>;
    abortActiveRequest(): void;
    fetch(url: string, options?: RequestInit, abortPrevious?: boolean): Promise<Response>;
    private isJsonLike;
    parseJson(jsonString: string): any | null;
    private parseTime;
    private scheduleChange;
    fetchFunction<T = any>(functionName: string, data?: Record<string, any>, abortPrevious?: boolean): Promise<T | string>;
    sync(...prefixes: string[]): Promise<void>;
    fetchAndUpdateBodyContent(): Promise<void>;
    copyCode(btnElement: HTMLElement, containerClass: string, initialIconAttr: {
        [key: string]: string;
    }, successIconAttr: {
        [key: string]: string;
    }, iconSelector?: string, timeout?: number): void;
    getCookie(name: string): string | null;
}
export declare class PPHPLocalStore {
    state: LocalStoreState;
    private static instance;
    private listeners;
    private pphp;
    private STORAGE_KEY;
    private lastSyncedState;
    private constructor();
    static getInstance(initialState?: LocalStoreState): PPHPLocalStore;
    setState(update: Partial<LocalStoreState>, syncWithBackend?: boolean): void;
    private saveState;
    private loadState;
    resetState(id?: string, syncWithBackend?: boolean): void;
}
export declare class SearchParamsManager {
    private static instance;
    private listeners;
    private constructor();
    static getInstance(): SearchParamsManager;
    get params(): URLSearchParams;
    get(key: string): string | null;
    set(key: string, value: string): void;
    delete(key: string): void;
    replace(params: Record<string, string | null>): void;
    private updateURL;
    listen(callback: SearchParamsListener): void;
    private notifyListeners;
    enablePopStateListener(): void;
}
declare var pphp: PPHP;
declare var store: PPHPLocalStore;
declare var searchParams: SearchParamsManager;
export { pphp, store, searchParams };
